{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Let's assume that we have a piece of code that we are not familiar with. For instant this trivial function: def foobar () -> 123 : pass We would like to find path to the certain object existing in runtime. In our case we would like to find out how to programmatically access 123 in annotation of the returned value. We can guess that this information is somehow bundled to the function itself. Base on that, we can apply digitout to this target: import digitout digitout ( foobar ) digitout will open an interactive dialog where we need to specify what we are looking for by defining constraint expression. digitout will traverse through the memory and stop at the first match. Alternatively we can pipe all the paths to another tool like fzf , which will help to find the object of our choice. Let's watch how it works:","title":"Overview"},{"location":"#overview","text":"Let's assume that we have a piece of code that we are not familiar with. For instant this trivial function: def foobar () -> 123 : pass We would like to find path to the certain object existing in runtime. In our case we would like to find out how to programmatically access 123 in annotation of the returned value. We can guess that this information is somehow bundled to the function itself. Base on that, we can apply digitout to this target: import digitout digitout ( foobar ) digitout will open an interactive dialog where we need to specify what we are looking for by defining constraint expression. digitout will traverse through the memory and stop at the first match. Alternatively we can pipe all the paths to another tool like fzf , which will help to find the object of our choice. Let's watch how it works:","title":"Overview"},{"location":"api/","text":"API \u00b6 digitout_silent ( target , config = None , context = None ) \u00b6 Show source code in digitout/app.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def digitout_silent ( target , config = None , context = None ): \"\"\" Silent version of [digitout_verbose][digitout.app.digitout_verbose]. It is dedicated to the users who don't want the results to get printed in the console. This is a good choice if one would like to integrate digitout with his application. Arguments and returned value are the same as for [digitout_verbose][digitout.app.digitout_verbose]. \"\"\" if config is None : config = DEFAULT_CONFIG elif isinstance ( config , str ): config = load_config ( config ) findall = False interactive = False verbose = False dio = DigItOut ( config , findall , interactive , verbose , context ) return dio . search ( target ) Silent version of digitout_verbose . It is dedicated to the users who don't want the results to get printed in the console. This is a good choice if one would like to integrate digitout with his application. Arguments and returned value are the same as for digitout_verbose . digitout_verbose ( target , config = None , context = None ) \u00b6 Show source code in digitout/app.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def digitout_verbose ( target : Any , config : Union [ type ( None ), str , dict ] = None , context : Union [ type ( None ), dict ] = None ) -> Tuple [ str , dict ]: \"\"\" Traverses through the Python structures until constraint defined in the config is met. This function is designed for finding path to the objects that you don't know how to get to. This function can be called by calling `digitout` module itself. E.g. ```python import digitout digitout(foobar) ``` Arguments: target: Top-level object where searching should start from. config: `None` - Open TUI if TTY available, or load default config otherwise. `str` instance - name of the config to get loaded. `dict` instance - config given explicitly. context: Variables that should be accessible to the lambda expressions defined in the config. Usually `locals()` is passed. Returns: `(path, match)` pair, where `path` - expressions that evaluates to the match, or `None` if match not found. `match` - `dict` of the keys which are args of the *Target Constraint* and values corresponding the the match, or `None` if match not found. \"\"\" if config is None : if sys . stdout . isatty (): config = open_tui () else : config = DEFAULT_CONFIG elif isinstance ( config , str ): config = load_config ( config ) findall = True interactive = sys . stdout . isatty () verbose = True dio = DigItOut ( config , findall , interactive , verbose , context ) return dio . search ( target ) Traverses through the Python structures until constraint defined in the config is met. This function is designed for finding path to the objects that you don't know how to get to. This function can be called by calling digitout module itself. E.g. import digitout digitout ( foobar ) Parameters Name Type Description Default target Any Top-level object where searching should start from. required config Union[NoneType, str, dict] None - Open TUI if TTY available, or load default config otherwise. str instance - name of the config to get loaded. dict instance - config given explicitly. None context Union[NoneType, dict] Variables that should be accessible to the lambda expressions defined in the config. Usually locals() is passed. None Returns Type Description Tuple[str, dict] (path, match) pair, where path - expressions that evaluates to the match, or None if match not found. match - dict of the keys which are args of the Target Constraint and values corresponding the the match, or None if match not found.","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#digitout.app.digitout_silent","text":"Show source code in digitout/app.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def digitout_silent ( target , config = None , context = None ): \"\"\" Silent version of [digitout_verbose][digitout.app.digitout_verbose]. It is dedicated to the users who don't want the results to get printed in the console. This is a good choice if one would like to integrate digitout with his application. Arguments and returned value are the same as for [digitout_verbose][digitout.app.digitout_verbose]. \"\"\" if config is None : config = DEFAULT_CONFIG elif isinstance ( config , str ): config = load_config ( config ) findall = False interactive = False verbose = False dio = DigItOut ( config , findall , interactive , verbose , context ) return dio . search ( target ) Silent version of digitout_verbose . It is dedicated to the users who don't want the results to get printed in the console. This is a good choice if one would like to integrate digitout with his application. Arguments and returned value are the same as for digitout_verbose .","title":"digitout_silent()"},{"location":"api/#digitout.app.digitout_verbose","text":"Show source code in digitout/app.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def digitout_verbose ( target : Any , config : Union [ type ( None ), str , dict ] = None , context : Union [ type ( None ), dict ] = None ) -> Tuple [ str , dict ]: \"\"\" Traverses through the Python structures until constraint defined in the config is met. This function is designed for finding path to the objects that you don't know how to get to. This function can be called by calling `digitout` module itself. E.g. ```python import digitout digitout(foobar) ``` Arguments: target: Top-level object where searching should start from. config: `None` - Open TUI if TTY available, or load default config otherwise. `str` instance - name of the config to get loaded. `dict` instance - config given explicitly. context: Variables that should be accessible to the lambda expressions defined in the config. Usually `locals()` is passed. Returns: `(path, match)` pair, where `path` - expressions that evaluates to the match, or `None` if match not found. `match` - `dict` of the keys which are args of the *Target Constraint* and values corresponding the the match, or `None` if match not found. \"\"\" if config is None : if sys . stdout . isatty (): config = open_tui () else : config = DEFAULT_CONFIG elif isinstance ( config , str ): config = load_config ( config ) findall = True interactive = sys . stdout . isatty () verbose = True dio = DigItOut ( config , findall , interactive , verbose , context ) return dio . search ( target ) Traverses through the Python structures until constraint defined in the config is met. This function is designed for finding path to the objects that you don't know how to get to. This function can be called by calling digitout module itself. E.g. import digitout digitout ( foobar ) Parameters Name Type Description Default target Any Top-level object where searching should start from. required config Union[NoneType, str, dict] None - Open TUI if TTY available, or load default config otherwise. str instance - name of the config to get loaded. dict instance - config given explicitly. None context Union[NoneType, dict] Variables that should be accessible to the lambda expressions defined in the config. Usually locals() is passed. None Returns Type Description Tuple[str, dict] (path, match) pair, where path - expressions that evaluates to the match, or None if match not found. match - dict of the keys which are args of the Target Constraint and values corresponding the the match, or None if match not found.","title":"digitout_verbose()"},{"location":"configuration/","text":"Configuration \u00b6 Default Configuration \u00b6 If you call digitout() with your target as the only parameter and pipe the results to another process (TTY unavailable), default configuration will be used. It matches every object met while traversing. Visitors used for traversing are set up according to the common sense. Ad Hoc Configuration \u00b6 When TTY is available, calling digitout() with your target as the only parameter will open an interactive interface where you can specify how memory should be traversed and what we are searching for. Configuration can be assigend to a name and reused later. Configurations are stored under ~/.config/digitout/configs 1 . A Priori Configuration \u00b6 If TTY is not available, but you are not satisfied with default configuration, you can use one of the custom configurations, buy passing its name to digitout() . E.g.: import digitout digitout ( mytarget , config = 'myconfig' ) Configurations can be edited interactively by invoking: python -m digitout Fixed Configuration \u00b6 Finally there is an option of passing configuration as a dictionary. The best way is to initialize dictionary with default values and modify them later. E.g.: import digitout from digitout import make_default_config config = make_default_config() config['match']['expression'] = 'lambda value: value == 123' digitout(mytarget, config) With default XDG settings. \u21a9","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#default-configuration","text":"If you call digitout() with your target as the only parameter and pipe the results to another process (TTY unavailable), default configuration will be used. It matches every object met while traversing. Visitors used for traversing are set up according to the common sense.","title":"Default Configuration"},{"location":"configuration/#ad-hoc-configuration","text":"When TTY is available, calling digitout() with your target as the only parameter will open an interactive interface where you can specify how memory should be traversed and what we are searching for. Configuration can be assigend to a name and reused later. Configurations are stored under ~/.config/digitout/configs 1 .","title":"Ad Hoc Configuration"},{"location":"configuration/#a-priori-configuration","text":"If TTY is not available, but you are not satisfied with default configuration, you can use one of the custom configurations, buy passing its name to digitout() . E.g.: import digitout digitout ( mytarget , config = 'myconfig' ) Configurations can be edited interactively by invoking: python -m digitout","title":"A Priori Configuration"},{"location":"configuration/#fixed-configuration","text":"Finally there is an option of passing configuration as a dictionary. The best way is to initialize dictionary with default values and modify them later. E.g.: import digitout from digitout import make_default_config config = make_default_config() config['match']['expression'] = 'lambda value: value == 123' digitout(mytarget, config) With default XDG settings. \u21a9","title":"Fixed Configuration"}]}